/******** DO NOT EDIT THIS FILE ********/
/* This is the busy waiting consumer application/simulation 
 * Type:
 *      ./bin/bwait_consumer_<mutex_type> 
 * for usage, where <mutex_type> is replaced by one of noop, lockvar or 
 * peterson, e.g.:
 *      ./bin/bwait_consumer_noop
 * gives a usage message.
 *
 * The source code for the usage message is in proc_setup in proc.c.
 */
#include <stdio.h>
#include <unistd.h>
#include <stdbool.h>
#include "joblog.h"
#include "ipc_jobqueue.h"
#include "mutex.h"

int main(int argc, char** argv) {
    // set queue and mutex constructors and destructors for setup 
    shobj_ctrl_t queue_ctrl = { (constructor_t) ipc_jq_new, 
                                (destructor_t) ipc_jq_delete };
    shobj_ctrl_t mutex_ctrl = { (constructor_t) mu_new, 
                                (destructor_t) mu_delete };
    
    proc_t* proc = proc_setup(argc, argv, BWAIT_CONS_PROC, &queue_ctrl,
        &mutex_ctrl);   // defined in proc.h
        
    if (!proc)
        error_exit("proc_setup failure");

    if (jlog_init(proc) == -1) {
        proc_delete(proc);
        error_exit("could not initialise job log");
    }

    while (proc->jobs) {
        job_t j;
        bool dq = false;
        
        mu_enter(proc->mutex);
        if (!ipc_jq_is_empty(proc->queue)) {
            j = ipc_jq_dequeue(proc->queue);
            dq = true;
        }
        mu_leave(proc->mutex);
        
        if (dq) {
            jlog_write_entry(proc, &j);
            proc->jobs--;
            proc->skips = 0;
        } else {
            proc->skips++;
        }       
        
        do_noncritical_work(proc);     

        printf(".");
        fflush(stdout);

        if (proc->skips >= proc->skip_limit)
            break;
    }
    
    printf("\n");
    
    proc_teardown(proc);    // defined in proc.h
    
    return EXIT_SUCCESS;
}
