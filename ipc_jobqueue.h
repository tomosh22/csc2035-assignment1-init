/******** DO NOT EDIT THIS FILE ********/

#ifndef _IPC_JOBQUEUE_H
#define _IPC_JOBQUEUE_H
#include <stdbool.h>
#include "jobqueue.h"
#include "ipc.h"

/* 
 * Introduction
 * 
 * This header file defines an ipc_jobqueue type and its "interface", the
 * functions that operate on the queue:
 *      ipc_jq_new(proc_t* proc);
 *      ipc_jq_capacity(ipc_jobqueue_t* ijq);
 *      ipc_jq_dequeue(ipc_jobqueue_t* ijq);
 *      ipc_jq_enqueue(ipc_jobqueue_t* ijq, job_t j);
 *      ipc_jq_is_empty(ipc_jobqueue_t* ijq);
 *      ipc_jq_is_full(ipc_jobqueue_t* ijq);
 *      ipc_jq_peekhead(ipc_jobqueue_t* ijq);
 *      ipc_jq_peektail(ipc_jobqueue_t* ijq);
 *      ipc_jq_delete(ipc_jobqueue_t* ijq);
 *
 * These are direct counterparts for jobqueue function (see jobqueue.h). 
 * This is because, except for ipc_jq_new and ipc_jq_delete, each ipc_jobqueue  
 * function is a wrapper for the corresponding jobqueue function. That is, 
 * ipc_jq_capacity calls jq_capacity and ipc_jq_dequeue calls jq_dequeue and 
 * so on to perform the actual queue operations.
 *
 * The difference between a jobqueue and an ipc_jobqueue is that a jobqueue
 * is allocated on the heap in the address space of a single process, whereas
 * an ipc_jobqueue is a wrapper for a jobqueue that is allocated in an area
 * of shared memory that is set up as part of ipc object creation and is mapped
 * to the address spaces of multiple processes. Therefore, a jobqueue is
 * private to a single process, whereas a jobqueue wrapped by an 
 * ipc_jobqueue can be accessed by multiple processes and a change to the 
 * queue by one process is seen by the others.
 *
 * The usage of a jobqueue and an ipc_jobqueue is almost identical.
 *
 * Another difference between an ipc_jobqueue and a jobqueue is that, for 
 * simulation purposes, in each of the functions that for each of its functions
 * (except new, capacity and delete), a critical work delay is injected 
 * by a call to do_critical_work with the proc field of the ipc_jobqueue object.
 *
 * IMPORTANT:
 * Only operate on an ipc_jobqueue using the functions defined in 
 * this file. Using an ipc_jobqueue in any other way can result in undefined 
 * and erroneous behaviour.
 *
 * See jobqueue.h for details of jobqueue operations.
 * See proc.h for the do_critical_work function.
 */
 
 
/* 
 * Type alias to define the ipc_jobqueue_t type as an alias for ipc_t.
 *
 * This means that the object used for the underlying queue (a jobqueue) is 
 * allocated in shared memory and accessible via the addr field of the 
 * ipc_t object.
 *
 * See: ipc.h
 */
typedef ipc_t ipc_jobqueue_t;

/*
 * ipc_jq_new(proc_t* proc)
 * 
 * Creates a new ipc_jobqueue (allocating resources for the queue).
 *
 * The ipc_jobqueue type is an alias for and ipc object where the addr 
 * field is for a jobqueue in shared memory.
 * 
 * Parameters:
 * proc - the non-null descriptor of a process sharing this queueu
 *
 * Return:
 * On success: a well-formed ipc object that encapsulates the queue in 
 * shared memory. If proc is the init process, the jobqueue is initialised.
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned and errno will be 
 * set as follows:
 *      EINVAL - invalid argument if proc is NULL
 *      Other values as specified by the system library functions used to
 *      implement the function (see ipc_new in ipc.h)
 *
 * See also:
 * proc.h - for a description of the proc type
 * ipc.h - for the ipc type for which the mutex is an alias
 */
ipc_jobqueue_t* ipc_jq_new(proc_t* proc);

/*
 * ipc_jq_capacity(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_capacity.
 *
 * See the specification of jq_capacity in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that jq is not NULL.
 */
size_t ipc_jq_capacity(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_dequeue(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_dequeue.
 *
 * See the specification of jq_dequeue in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
job_t ipc_jq_dequeue(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_enqueue(ipc_jobqueue_t* ijq, job-t j)
 *
 * This is a wrapper for jq_enqueue.
 *
 * See the specification of jq_enqueue in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
void ipc_jq_enqueue(ipc_jobqueue_t* ijq, job_t j);

/*
 * ipc_jq_is_empty(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_is_empty.
 *
 * See the specification of jq_is_empty in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
bool ipc_jq_is_empty(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_is_full(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_is_full.
 *
 * See the specification of jq_is_full in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
bool ipc_jq_is_full(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_peekhead(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_peekhead.
 *
 * See the specification of jq_peekhead in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
job_t ipc_jq_peekhead(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_peektail(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for jq_peektail.
 *
 * See the specification of jq_peektail in jobqueue.h.
 *
 * If ijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that ijq is not NULL.
 */
job_t ipc_jq_peektail(ipc_jobqueue_t* ijq);

/*
 * ipc_jq_delete(ipc_jobqueue_t* ijq)
 * 
 * Deletes a ipc_jobqueue, deallocating resources associated with the queue.
 * 
 * Parameters:
 * ijq - a non-null pointer to the ijq to delete
 *
 * Return:
 * There is no return value for the function. If ijq is not NULL and the call 
 * succeeds, resources associated with the queue have been freed. If ijq is 
 * NULL this function has no effect.
 *
 * Errors:
 * Various errors with access to any underlying shared memory object may occur
 * in which case the process is likely to terminate with a memory error.
 */
void ipc_jq_delete(ipc_jobqueue_t* ijq);

#endif