/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <unistd.h>
#include <string.h>
#include "proc.h"

#define MIN_WORK_DEFAULT 20
#define MAX_WORK_DEFAULT 40
#define PROC_SKIP_FACTOR 2

static void proc_action_msg(proc_t* proc, char* action) {
    printf("%s %d %s\n", proc->name, proc->id, action);
}

static void print_usage(char** argv) {
    printf( "usage: %s <id> <jobs> [-i] [-ds <ms>] [-de <ms>]\n\
            [-w <min_crit> <max_crit> [<min_ncrit> <max_ncrit>]]\n", argv[0]);
            
    printf( "       id is a positive number between 0 and 99\n"
            "       jobs is the number of jobs to process >= 1\n"
            "       -i  = the init process sets up shared objects etc,\n"
            "             there should be one and only one init process\n"
            "       -ds = delay this process by 1s before starting work\n"
            "       -de = delay this process by 1s after finishing work\n"
            "       -w  = specify ranges for critical and non-critical work\n"
            "             as pairs of min and max values, defaults are:\n"
            "             (10, 100) and (10, 100) - non-critical work is the\n"
            "             same as critical work if not specified\n");
}

static void delay_randms(long min_ms, long max_ms) {
    if (min_ms < 1 || max_ms <= min_ms)
        return;
        
    long ms = (random() % (max_ms - min_ms + 1)) + min_ms;
    
    delay_ms(ms);
}

void error_exit(const char* err_msg) {
    perror(err_msg);
    exit(EXIT_FAILURE);
}

void do_noncritical_work(proc_t* proc) {
    delay_randms(proc->noncrit_work.min, proc->noncrit_work.max); 
}

void do_critical_work(proc_t* proc) {
    delay_randms(proc->crit_work.min, proc->crit_work.max); 
}

void delay_ms(long ms) {
    if (ms < 1)
        return;
        
    struct timespec req;
    
    req.tv_sec = ms / 1000;
    req.tv_nsec = (ms - (req.tv_sec * 1000)) * 1000000L;
    
    nanosleep(&req, NULL);
}

proc_t* proc_init(int argc, char** argv, proctype_t type) {    
    if (argc < 3) {
        print_usage(argv);
        exit(EXIT_FAILURE);
    }
    
    char name[MAX_FILENAME_LEN + 1];
    strncpy(name, argv[0], MAX_FILENAME_LEN);
    int id = atoi(argv[1]);
    int jobs = atoi(argv[2]);
    bool is_init = false;
    long delay_start = 0;
    long delay_exit = 0;
    
    work_ms_t crit_work = { MIN_WORK_DEFAULT, MAX_WORK_DEFAULT };
    work_ms_t noncrit_work = crit_work;
    
    if (argc >= 4) {
        int next_arg = 3;
        
        if (strncmp(argv[next_arg], "-i", 2) == 0) {
            next_arg++;
            is_init = true;
        }
        
        if (argc > next_arg && strncmp(argv[next_arg], "-ds", 3) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 1) {
                delay_start = atol(argv[next_arg]);
                next_arg++;
            }
        }
                
        if (argc > next_arg && strncmp(argv[next_arg], "-de", 3) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 1) {
                delay_exit = atol(argv[next_arg]);
                next_arg++;
            }
        }

        if (argc > next_arg && strncmp(argv[next_arg], "-w", 2) == 0) {
            next_arg++;
            if ((argc - next_arg) >= 2) {
                crit_work.min = atol(argv[next_arg]);
                next_arg++;
                crit_work.max = atol(argv[next_arg]);
                next_arg++;

                if ((argc - next_arg) == 2) {
                    noncrit_work.min = atol(argv[next_arg]);
                    next_arg++;
                    noncrit_work.max = atol(argv[next_arg]);
                } else {
                    noncrit_work.min = crit_work.min;
                    noncrit_work.max = crit_work.max;
                }
            }
        }
    }

    // seed random number generator
    time_t t;
    srandom((unsigned) time(&t));
    
    return proc_new(type, name, id, jobs, is_init, delay_start,
        delay_exit, crit_work, noncrit_work);
}

proc_t* proc_new(proctype_t type, char* name, int id, int jobs, bool is_init, 
    int delay_start, int delay_exit, work_ms_t crit_work, 
    work_ms_t noncrit_work) {
    if (id < MIN_ID || id > MAX_ID || jobs < 1)
        return NULL;
    
    proc_t* proc = (proc_t*) malloc(sizeof(proc_t));
    
    if (proc) {
        proc->type = type;
        strncpy(proc->name, name, MAX_FILENAME_LEN);
        proc->id = id;
        proc->jobs = jobs;
        proc->is_init = is_init;
        proc->delay_start = delay_start;
        proc->delay_exit = delay_exit;
        proc->crit_work = crit_work;
        proc->noncrit_work = noncrit_work;
        proc->queue = NULL;
        proc->queue_destructor = NULL;
        proc->mutex = NULL;
        proc->mutex_destructor = NULL;
        proc->skips = 0;
        proc->skip_limit = PROC_SKIP_FACTOR * jobs;
    }
        
    return proc;
}

void proc_delete(proc_t* proc) {
    free(proc);
}

proc_t* proc_setup(int argc, char** argv, int proc_type, 
    shobj_ctrl_t* queue_ctrl, shobj_ctrl_t* mutex_ctrl) {
    proc_t* proc = proc_init(argc, argv, proc_type);
    
    if (proc) {
        proc_action_msg(proc, "starting...");
        
        delay_ms(proc->delay_start);

        proc->queue = queue_ctrl->constructor(proc);
        if (!proc->queue) {
            proc_delete(proc);
            return NULL;
        }
        
        proc->queue_destructor = queue_ctrl->destructor;
        
        if (mutex_ctrl) {
            proc->mutex = mutex_ctrl->constructor(proc);
            
            if (!proc->mutex) {
                proc->queue_destructor(proc->queue);
                proc_delete(proc);
                return NULL;
            }
            
            proc->mutex_destructor = mutex_ctrl->destructor;
        }
    } else
        error_exit("could not create proc descriptor struct");
    
    return proc; 
}

void proc_teardown(proc_t* proc) {
    static const char* stopmsg_fmt = "stopping with %d %s to do";

    delay_ms(proc->delay_exit);
    
    if (proc->mutex)
        proc->mutex_destructor(proc->mutex);
        
    proc->queue_destructor(proc->queue);
    
    char* job_summary;

    asprintf(&job_summary, stopmsg_fmt, proc->jobs, 
            proc->jobs == 1 ? "job" : "jobs");
    
    proc_action_msg(proc, job_summary);
    
    free(job_summary);
    proc_delete(proc);
}
