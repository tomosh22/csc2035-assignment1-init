/******** DO NOT EDIT THIS FILE ********/
#ifndef _SEM_IPCJOBQUEUE_H
#define _SEM_IPCJOBQUEUE_H
#include <stdbool.h>
#include <semaphore.h>
#include "ipc_jobqueue.h"

// TOOD FOR SEMAPHORE VERSION

/* 
 * Introduction
 * 
 * This header file defines an sem_ipc_jobqueue type and its "interface", the
 * functions that operate on the queue:
 *      sem_ijq_new(proc_t* proc);
 *      sem_ijq_capacity(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_dequeue(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_enqueue(sem_ipc_jobqueue_t* ijq, job_t j);
 *      sem_ijq_is_empty(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_is_full(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_peekhead(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_peektail(sem_ipc_jobqueue_t* ijq);
 *      sem_ijq_delete(sem_ipc_jobqueue_t* ijq);
 *
 * These are direct counterparts for ipc_jobqueue functions (see
 * ipc_jobqueue.h). 
 * This is because, except for sem_ijq_new and sem_ijq_delete, each
 * sem_ipc_jobqueue function is a wrapper for the corresponding ipc_jobqueue
 * function, with appropriate semaphore operations for maintenance of 
 * integrity. That is, sem_ijq_capacity calls ipc_jq_capacity and 
 * sem_ijq_dequeue calls ipc_jq_dequeue and so on to perform the actual 
 * queue operations.
 *
 * The main difference between an ipc_jobqueue and a sem_ipc_jobqueue is that
 * the sem_ipc_jobqueue functions use appropriate semaphore operations before
 * and after calling the corresponding ipc_jobqueue function to maintain the 
 * integrity of the underlying shared queue.
 *
 * Otherwise, the usage of an ipc_jobqueue (and an underlying jobqueue) and a 
 * sem_ipc_jobqueue are almost identifical
 *
 * IMPORTANT:
 * Only operate on a sem_ipc_jobqueue using the functions defined in 
 * this file. Using a sem_ipc_jobqueue in any other way can result in undefined 
 * and erroneous behaviour.
 *
 * See ipc_jobqueue.h for details of ipc_jobqueue operations and documentation
 * See jobqueue.h for details of jobqueue operations.
 */

/* 
 * Definition of struct sem_ipc_jobqueue. The struct associates a ipc_jobqueue
 * with semaphores to protect the integrity of the queue when shared by 
 * multiple processes
 *
 * Type alias:
 * A struct sem_ipc_jobqueue can also be referred to as sem_ipc_jobqueue_t
 *
 * Fields:
 * mutex - a binary mutex semaphore that acts as a lock (is acquired or not) 
 *          and is initialised to available (1)
 * full - a counting semaphore that is initialised to unavailable (0), there
 *          no entries in the queue
 * empty - a counting semaphore that is initialised to the capacity of the 
 *          queue - the number of slots that are available
 * ijq - the ipc_queue that encapsulates a jobqueue in shared memory
 */
typedef struct sem_ipc_jobqueue {
    sem_t* mutex;
    sem_t* full;
    sem_t* empty;
    ipc_jobqueue_t* ijq;
} sem_ipc_jobqueue_t;

/*
 * sem_ijq_new(proc_t* proc)
 * 
 * Creates a new sem_ipc_jobqueue (allocating semaphores and other resources 
 * for the queue).
 *
 * Parameters:
 * proc - the non-null descriptor of a process sharing this queueu
 *
 * Return:
 * On success: a well-formed sem_ipc_jobqueue object that encapsulates the 
 *      queue and associated semaphores
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned and errno will be 
 * set as follows:
 *      EINVAL - invalid argument if proc is NULL
 *      Other values as specified by the system library functions used to
 *      implement the function (see ipc_new in ipc.h and sem_open)
 *
 * See also:
 * proc.h - for a description of the proc type
 * ipc.h - for the ipc type for which the mutex is an alias
 * manual pages for sem_open to create semaphores, and for sem_wait, sem_post 
 *      and sem_delete for possible errors
 */
sem_ipc_jobqueue_t* sem_ijq_new(proc_t* proc);

/*
 * sem_ijq_capacity(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_jq_capacity.
 *
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 *
 * See the specification of ipc_jq_capacity in ipc_jobqueue.h.
 */
size_t sem_ijq_capacity(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_dequeue(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_jq_enqueue.
 *
 * Important notes: 
 * If the queue is empty, the calling function will block until another 
 * process enqueues a job. This means that it is unnecessary to check 
 * whether the queue is empty before calling this function.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return without dequeueing a job and the state of the queue will not
 * be updated.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 *
 * Return:
 * On success, the job at the head of the queue is returned and the state
 *      of the queue is updated.
 * On failure of a sem_wait, the unused entry is returned and the state of 
 *      the queue is not updated.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h.
 * Errors resulting from system calls sem_wait and sem_post are possible..
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
job_t sem_ijq_dequeue(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_enqueue(sem_ipc_jobqueue_t* sijq, job-t j)
 *
 * This is a wrapper for ipc_jq_enqueue.
 *
 * Important notes: 
 * If the queue is full, the calling function will block until another 
 * process dequeues a job. This means that it is unnecessary to check 
 * whether the queue is full before calling this function.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return without enqueueing the job and the state of the queue will not
 * be updated.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h
 * Errors resulting from system calls sem_wait and sem_post are possible..
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
void sem_ijq_enqueue(sem_ipc_jobqueue_t* sijq, job_t j);

/*
 * sem_ijq_is_empty(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_jq_is_empty.
 *
 * Important notes: 
 * This function will block until a semaphore protecting the queue is available.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return false regardless of the state of the queue.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 *
 * Return:
 * On success, true if the queue is empty and false otherwise.
 * On failure of a sem_wait call, false.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h
 * Errors resulting from system calls sem_wait and sem_post are possible..
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
bool sem_ijq_is_empty(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_is_full(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_jq_is_full.
 *
 * Important notes: 
 * This function will block until a semaphore protecting the queue is available.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return false regardless of the state of the queue.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 *
 * Return:
 * On success, true if the queue is full and false otherwise.
 * On failure of a sem_wait call, false.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h
 * Errors resulting from system calls sem_wait and sem_post are possible.
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
bool sem_ijq_is_full(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_peekhead(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_peekhead.
 *
 * Important notes: 
 * This function will block until a semaphore protecting the queue is available.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return the unused entry regardless of the state of the queue.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 * This function does not change the state of the queue.
 *
 * Return:
 * On success, the entry at the head of the queue or the unused entry if the 
 *      queue is empty
 * On failure of a sem_wait call, the unused entry.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h
 * Errors resulting from system calls sem_wait and sem_post are possible.
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
job_t sem_ijq_peekhead(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_peektail(sem_ipc_jobqueue_t* sijq)
 *
 * This is a wrapper for ipc_peektail.
 *
 * Important notes: 
 * This function will block until a semaphore protecting the queue is available.
 * If a sem_wait call on a semaphore protecting the queue fails, this function
 * will return the unused entry regardless of the state of the queue.
 * If sijq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that sijq is not NULL.
 * This function does not change the state of the queue.
 *
 * Return:
 * On success, the entry at the tail of the queue or the unused entry if the 
 *      queue is empty
 * On failure of a sem_wait call, the unused entry.
 *
 * Errors:
 * See errors specified in ipc_jobqueue.h and jobqueue.h
 * Errors resulting from system calls sem_wait and sem_post are possible.
 *
 * See also:
 * ipc_jobqueue.h and jobqueue.h
 * man pages for sem_wait and sem_post
 */
job_t sem_ijq_peektail(sem_ipc_jobqueue_t* sijq);

/*
 * sem_ijq_delete(sem_ipc_jobqueue_t* sijq)
 * 
 * Deletes a sem_ipc_jobqueue, deallocating resources associated with the
 * queue, including closing semaphores.
 * 
 * Parameters:
 * sijq - a non-null pointer to the ijq to delete
 *
 * Return:
 * There is no return value for the function. If sijq is not NULL and the call 
 * succeeds, resources associated with the the queue have been freed. If sijq is 
 * NULL this function has no effect.
 *
 * Errors:
 * Various errors with access to any underlying shared memory object may occur
 * in which case the process is likely to terminate with a memory error.
 */
void sem_ijq_delete(sem_ipc_jobqueue_t* sijq);




#endif
