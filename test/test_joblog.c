/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include "test_joblog.h"
#include "procs4tests.h"
#include "../joblog.h"

#define LOG_FILES 4
#define JOBLOG_ENTRY_SIZE 10
#define TEST_ENTRY_NUM 11
#define JOBLOG_PATH "./out"
#define ENTRY_FORMAT "%05dp00"

static char* log_fname[LOG_FILES] = {
    "out/bwait_cons00.txt",
    "out/bwait_prod01.txt",
    "out/bwait_cons02.txt",
    "out/bwait_prod03.txt"
};

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void* test_setup(const MunitParameter params[], void* user_data) {
    proc_t* p = new_test_proc(91);
    p->is_init = true;
    
    jlog_init(p);
    
    proc_delete(p);  

    return NULL;
}

static void test_tear_down(void* fixture) {
    for (int i = 0; i < LOG_FILES; i++)
        unlink(log_fname[i]);
}

static MunitResult test_cpid_jlog_write_entry(int cp_id) {
    job_t job = { -1, 0 };
    
    errno = 0;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        job.id = i;
        
        proc_t* proc = new_test_proc(cp_id);
        
        jlog_write_entry(proc, &job);
        
        proc_delete(proc);
    }
    
    assert_int(errno, ==, 0);
    
    FILE* lf = fopen(log_fname[cp_id], "r");
    
    if (!lf) 
        return MUNIT_FAIL;
    
    char actual[JOBLOG_ENTRY_SIZE];
    char expected[JOBLOG_ENTRY_SIZE];
    int i = 0;
    while (i < TEST_ENTRY_NUM && fgets(actual, JOBLOG_ENTRY_SIZE, lf)) {
        if (actual[JOBLOG_ENTRY_SIZE - 2] == '\n') 
            actual[JOBLOG_ENTRY_SIZE - 2] = '\0';
        
        snprintf(expected, JOBLOG_ENTRY_SIZE, ENTRY_FORMAT, i);

        assert_string_equal(actual, expected);
        i++;
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    
    fclose(lf);
    
    return MUNIT_OK;
}

static MunitResult test_cpid_jlog_read_entry(int cp_id) {
    proc_t* proc = new_test_proc(cp_id);
    
    char wentry[TEST_ENTRY_NUM][JOBLOG_ENTRY_SIZE];
    FILE* lf = fopen(log_fname[cp_id], "a");
    
    if (!lf)
        return MUNIT_FAIL;
    
    int i = 0;
    for (i = 0; i < TEST_ENTRY_NUM; i++) {
        snprintf(wentry[i], JOBLOG_ENTRY_SIZE, ENTRY_FORMAT, i);
        fprintf(lf, "%s\n", wentry[i]);
    }

    fclose(lf);
    
    errno = 0;
    
    char* rentry = jlog_read_entry(proc, -1);

    assert_null(rentry);
    assert_int(errno, ==, 0);
    
    rentry = jlog_read_entry(proc, TEST_ENTRY_NUM);

    assert_null(rentry);
    assert_int(errno, ==, 0);

    i = 0;
    
    while ((rentry = jlog_read_entry(proc, i))) {
        assert_string_equal(rentry, wentry[i]);
        free(rentry);
        i++;
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    assert_int(errno, ==, 0);

    return MUNIT_OK;  
}

static MunitResult test_jlog_init(const MunitParameter params[], 
    void* fixture) {    
    proc_t* p = new_test_proc(91);
    p->is_init = true;
    
    errno = 0;
    assert_int(jlog_init(p), ==, 0);
    
    assert_int(errno, ==, 0);
    
    struct stat sb;
    
    assert_int(stat(JOBLOG_PATH, &sb), ==, 0); 
    
    assert_true(S_ISDIR(sb.st_mode));

    errno = 0;
    assert_int(jlog_init(p), ==, 0);
    assert_int(errno, ==, 0);
    
    p->is_init = false;

    rmdir(JOBLOG_PATH);
    assert_true(access(JOBLOG_PATH, F_OK) == -1);
    assert_int(jlog_init(p), ==, 0);
    errno = 0;
    assert_int(stat(JOBLOG_PATH, &sb), ==, -1); 
    assert_int(errno, ==, ENOENT);

    proc_delete(p);
    
    errno = 0;
    
    assert_int(jlog_init(NULL), ==, -1);
    assert_int(errno, ==, EINVAL);
    
    errno = 0;
        
    return MUNIT_OK;
}

static MunitResult test_jlog_write_entry(const MunitParameter params[], 
    void* fixture) {
    MunitResult r = MUNIT_FAIL;
    
    for (int i = 0; i < LOG_FILES; i++) {
        r = test_cpid_jlog_write_entry(i);
        if (r != MUNIT_OK)
            break;        
    }
    
    errno = 0;
    
    job_t j = {0, 0};
    
    jlog_write_entry(NULL, &j);
    
    assert_int(errno, ==, 0);
    
    proc_t* proc = new_test_proc(98);
    
    jlog_write_entry(proc, NULL);
    
    assert_int(errno, ==, 0);
    
    proc_delete(proc);
        
    return r;
}

static MunitResult test_jlog_read_entry(const MunitParameter params[],
    void* fixture) {
    MunitResult r = MUNIT_FAIL;
    
    for (int i = 0; i < LOG_FILES; i++) {
        r = test_cpid_jlog_read_entry(i);

        if (r != MUNIT_OK)
            break;
    }
    
    errno = 0;
    
    char* x = jlog_read_entry(NULL, 0);
    
    assert_null(x);
    assert_int(errno, ==, 0);
    
    proc_t* proc = new_test_proc(99);
    
    x = jlog_read_entry(proc, 0);
        
    assert_null(x);
    assert_int(errno, ==, 0);
    
    proc_delete(proc);

    return r;  
}

static MunitResult test_jlog_delete(const MunitParameter params[],
    void* fixture) {
    for (int i = 0; i < LOG_FILES; i++) {
        FILE* lf = fopen(log_fname[i], "w");
        fclose(lf);
        
        if (access(log_fname[i], F_OK) == -1) 
            return MUNIT_FAIL;
        
        proc_t* proc = new_test_proc(i);   
        jlog_delete(proc);
        
        assert_int(errno, ==, 0);
        
        proc_delete(proc);
        
        errno = 0;
        
        assert_int(access(log_fname[i], F_OK), ==, -1);
        assert_int(errno, ==, ENOENT);  
    }
    
    errno = 0;
    
    return MUNIT_OK;
}
