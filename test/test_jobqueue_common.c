/******** DO NOT EDIT THIS FILE ********/
#include "test_jobqueue_common.h"
#include <stdio.h>

static void assert_first_job(test_jqueue_t* test_jq, job_t expected_job) {
    // first job is the job at the head
    assert_true(job_is_equal(test_jq->jobs[*test_jq->head], expected_job));
}

static void assert_last_job(test_jqueue_t* test_jq, job_t expected_job) {
    // last job is the job behind the tail
    int last_posn = (*test_jq->tail + *test_jq->buf_size - 1) %  
                            *test_jq->buf_size;
    
    assert_true(job_is_equal(test_jq->jobs[last_posn], expected_job));
}

static void assert_not_empty(test_jqueue_t* test_jq) {
    assert_int(*test_jq->head, !=, *test_jq->tail);
    
    bool is_empty = true;
    int i = 0;
    
    while (is_empty && i < *test_jq->buf_size) {
        is_empty = job_is_equal(test_jq->jobs[i], UNUSED_ENTRY);
        i++;
    }
    
    assert_false(is_empty);
    assert_true(job_is_equal(test_jq->jobs[*test_jq->tail], UNUSED_ENTRY));
}

static void assert_is_empty(test_jqueue_t* test_jq) {
    assert_int(*test_jq->head, ==, *test_jq->tail);
    
    assert_true(job_is_equal(test_jq->jobs[*test_jq->tail], UNUSED_ENTRY));
}

static void assert_not_full(test_jqueue_t* test_jq) {
    assert_int(*test_jq->head, !=, (*test_jq->tail + 1) % *test_jq->buf_size);
    assert_true(job_is_equal(test_jq->jobs[*test_jq->tail], UNUSED_ENTRY));
}

static void assert_is_full(test_jqueue_t* test_jq) {
    assert_int(*test_jq->head, ==, (*test_jq->tail + 1) % *test_jq->buf_size);
    
    assert_false(job_is_equal(test_jq->jobs[*test_jq->head], UNUSED_ENTRY));
    assert_true(job_is_equal(test_jq->jobs[*test_jq->tail], UNUSED_ENTRY));
}

static void assert_jobs_initialised(job_t* jobs, size_t buf_size, int head) {
    for (int i = 0; i < buf_size; i++)
        assert_true(job_is_equal(jobs[i], UNUSED_ENTRY));   
}

static void assert_noenqueue_tofull(test_jqueue_t* test_jq) {
    // tests enqueuing to full queue does not change queue state
    assert_is_full(test_jq);
    int unused_count = 0;
    job_t saved_jobs[*test_jq->buf_size];
    int head = *test_jq->head;
    int tail = *test_jq->tail;
    int buf_size = *test_jq->buf_size;
    
    for (int i = 0; i < buf_size; i++) {
        saved_jobs[i] = test_jq->jobs[i];
        if (job_is_equal(saved_jobs[i], UNUSED_ENTRY))
            unused_count++;
    }

    assert_int(unused_count, ==, 1);
    
    int test_enqueues = buf_size + (buf_size / 3);
    
    for (int i = 0; i < test_enqueues; i++) {
        job_t j = { i * 10, i + 20 };
        test_jq->enqueue(test_jq->q, j);
    }
    
    for (int i = 0; i < buf_size; i++)
        assert_true(job_is_equal(test_jq->jobs[i], saved_jobs[i]));
        
    assert_int(head, ==, *test_jq->head);
    assert_int(tail, ==, *test_jq->tail);
    assert_int(buf_size, ==, *test_jq->buf_size);
    
    assert_is_full(test_jq);
}

void assert_init_jobqueue_state(jobqueue_t* jq) {
    assert_not_null(jq);
    assert_int(jq->head, ==, 0);
    assert_int(jq->tail, ==, 0);
    assert_int(jq->buf_size, ==, JOBQ_BUF_SIZE);
    
    assert_jobs_initialised(jq->jobs, jq->buf_size, jq->head);    
    
    return;
}

MunitResult test_jqueue_capacity(test_jqueue_t* test_jq) {
    assert_int(test_jq->capacity(test_jq->q), ==, *test_jq->buf_size - 1);
   
    return MUNIT_OK;
}

MunitResult test_jqueue_is_full(test_jqueue_t* test_jq) {
    assert_false(test_jq->is_full(test_jq->q));
    assert_not_full(test_jq);
    
    for (int i = 0; i < test_jq->capacity(test_jq->q); i++) {
        job_t j = { i, i };
        test_jq->enqueue(test_jq->q, j);
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    assert_is_full(test_jq);
        
    return MUNIT_OK;
}

MunitResult test_jqueue_is_empty(test_jqueue_t* test_jq) {
    assert_true(test_jq->is_empty(test_jq->q));
    assert_is_empty(test_jq);
    
    for (int i = 0; i < test_jq->capacity(test_jq->q); i++) {
        job_t j = { i, i };
        test_jq->enqueue(test_jq->q, j);
    }
    
    assert_false(test_jq->is_empty(test_jq->q));
    assert_not_empty(test_jq);
        
    return MUNIT_OK;
}

MunitResult test_jqueue_enqueue_dequeue(test_jqueue_t* test_jq) {
    int i = 0;
    job_t j;

    assert_is_empty(test_jq);

    while (!test_jq->is_full(test_jq->q)) {
        j.id = i;
        j.pid = i + 1;
        test_jq->enqueue(test_jq->q, j);
        i++;
    }
    
    assert_int(i, ==, test_jq->capacity(test_jq->q));

    assert_not_empty(test_jq);
    assert_is_full(test_jq);
    
    // check first and last jobs
    job_t expected_first = { 0, 1 }; 
    job_t expected_last = { i - 1, i };
    assert_first_job(test_jq, expected_first); 
    assert_last_job(test_jq, expected_last);

    // try to enqueue more
    assert_noenqueue_tofull(test_jq);
    
    assert_not_empty(test_jq);
    assert_is_full(test_jq);
    assert_first_job(test_jq, expected_first); 
    assert_last_job(test_jq, expected_last);
        
    i = 0;
    
    while (!test_jq->is_empty(test_jq->q)) {
        job_t expected_j = { i, i + 1 };
        job_t j = test_jq->dequeue(test_jq->q);
        assert_true(job_is_equal(j, expected_j));
        i++;
    }
    
    assert_not_full(test_jq);
    assert_is_empty(test_jq);
    assert_jobs_initialised(test_jq->jobs, *test_jq->buf_size, *test_jq->head);
    
    int ops = *test_jq->buf_size;
    ops += ops / 2;

    for (i = 0; i < ops; i++) {
        job_t expected_j = { i, i + 1 };
        
        test_jq->enqueue(test_jq->q, expected_j);
        
        assert_true(job_is_equal(test_jq->dequeue(test_jq->q), expected_j));
    }
    
    assert_int(i, ==, ops);

    assert_not_full(test_jq);
    assert_is_empty(test_jq);
    assert_jobs_initialised(test_jq->jobs, *test_jq->buf_size, *test_jq->head);
    
    return MUNIT_OK;
}

MunitResult test_jqueue_peekhead(test_jqueue_t* test_jq) {
    assert_true(job_is_equal(test_jq->peekhead(test_jq->q), UNUSED_ENTRY));
    assert_first_job(test_jq, test_jq->peekhead(test_jq->q));
    
    int i = 0;
    job_t expected_j = { 0, 1 };
    
    while (!test_jq->is_full(test_jq->q)) {
        job_t j = { i, i+1 };
        test_jq->enqueue(test_jq->q, j);
        
        assert_first_job(test_jq, test_jq->peekhead(test_jq->q));
        assert_true(job_is_equal(test_jq->peekhead(test_jq->q), expected_j));
                
        i++;
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    assert_is_full(test_jq);
    
    i = 0;
    
    while (!test_jq->is_empty(test_jq->q)) {
        job_t j = { i, i+1 };

        assert_first_job(test_jq, test_jq->peekhead(test_jq->q));
        assert_true(job_is_equal(test_jq->peekhead(test_jq->q), j));
        
        (void) test_jq->dequeue(test_jq->q);
        
        i++;
    }
    
    assert_true(test_jq->is_empty(test_jq->q));
    assert_is_empty(test_jq);

    assert_true(job_is_equal(test_jq->peekhead(test_jq->q), UNUSED_ENTRY));

    return MUNIT_OK;
}

MunitResult test_jqueue_peektail(test_jqueue_t* test_jq) {
    assert_true(job_is_equal(test_jq->peektail(test_jq->q), UNUSED_ENTRY));

    int i = 0;

    while (!test_jq->is_full(test_jq->q)) {
        job_t j = { i, i+1 };
        test_jq->enqueue(test_jq->q, j);
        
        assert_last_job(test_jq, test_jq->peektail(test_jq->q));
        assert_true(job_is_equal(test_jq->peektail(test_jq->q), j));
                
        i++;
    }
    
    assert_true(test_jq->is_full(test_jq->q));
    
    job_t expected_j = { i - 1, i };
    while (!test_jq->is_empty(test_jq->q)) {
        assert_last_job(test_jq, test_jq->peektail(test_jq->q));
        assert_true(job_is_equal(test_jq->peektail(test_jq->q), expected_j));
        
        (void) test_jq->dequeue(test_jq->q);
    }
    
    assert_is_empty(test_jq);
    
    assert_true(job_is_equal(test_jq->peektail(test_jq->q), UNUSED_ENTRY));

    return MUNIT_OK;
}
