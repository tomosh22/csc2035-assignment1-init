/******** DO NOT EDIT THIS FILE ********/
#include <errno.h>
#include "../mutex_peterson.h"
#include "test_mutex_peterson.h"
#include "procs4tests.h"

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void* test_setup(const MunitParameter params[], void* user_data) {
    return new_test_procs();
}

static void test_tear_down(void* fixture) {
    delete_test_procs((test_procs_t*) fixture);
}


static mutex_t* assert_mu_new(proc_t* p) {
    mutex_t* m = mu_new(p);
    
    assert_not_null(m);
    assert_not_null(m->addr);
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    assert_int(mp->turn, ==, 0);
    assert_int(mp->interested[0], ==, 0);
    assert_int(mp->interested[1], ==, 0);

    return m;
}

static mutex_t* assert_mu_enter(proc_t* p) {
    mutex_t* m = assert_mu_new(p);
 
    mu_enter(m);
    
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    
    assert_int(mp->turn, ==, m->proc->id);
    assert_int(mp->interested[m->proc->id % 2], ==, 1);
    assert_int(mp->interested[1 - (m->proc->id % 2)], ==, 0);
    
    mp->interested[m->proc->id % 2] = 0;
    
    mu_enter(NULL);
    assert_int(mp->turn, ==, m->proc->id);
    assert_int(mp->interested[m->proc->id % 2], ==, 0);
    assert_int(mp->interested[1 - (m->proc->id % 2)], ==, 0);   
 
    return m;
}

static mutex_t* assert_mu_leave(proc_t* p) {
    mutex_t* m = assert_mu_new(p);
    mutex_peterson_t* mp = (mutex_peterson_t*) m->addr;
    
    int turn = mp->turn;
    mp->interested[m->proc->id % 2] = 1;
    
    mu_leave(m);
    
    assert_int(mp->turn, ==, turn);
    assert_int(mp->interested[m->proc->id % 2], ==, 0);
    
    mu_leave(NULL);

    assert_int(mp->turn, ==, turn);
    assert_int(mp->interested[m->proc->id % 2], ==, 0);

    return m;
}

static MunitResult test_mu_new(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    mutex_t* min = assert_mu_new(p->pin);
    mutex_t* mni = assert_mu_new(p->pni);
    
    mu_delete(mni);
    
    mu_delete(min);
    
    errno = 0;
    assert_null(mu_new(NULL));
    assert_int(errno, ==, EINVAL);
        
    return MUNIT_OK;
}

    
static MunitResult test_mu_enter(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    mutex_t* min = assert_mu_enter(p->pin);
    mutex_t* mni = assert_mu_enter(p->pni);

    mu_delete(min);
    mu_delete(mni);

    p->pin->id = 99;
    min = assert_mu_enter(p->pin);
            
    mu_delete(min);

    return MUNIT_OK;
}

static MunitResult test_mu_leave(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* p = fixture;
    mutex_t* min = assert_mu_leave(p->pin);
    mutex_t* mni = assert_mu_leave(p->pni);
    
    mu_delete(min);
    mu_delete(mni);

    p->pin->id = 99;
    min = assert_mu_leave(p->pin);
            
    mu_delete(min);

    return MUNIT_OK;
}
