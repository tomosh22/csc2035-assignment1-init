/******** DO NOT EDIT THIS FILE ********/
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <errno.h>
#include "test_jobqueue_common.h"
#include "test_sem_ipc_jobqueue.h"
#include "../sem_ipc_jobqueue.h"
#include "procs4tests.h"

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void* test_setup(const MunitParameter params[], void* user_data) {
    test_jqueue_t* test_jq = (test_jqueue_t*) malloc(sizeof(test_jqueue_t));
    
    sem_ipc_jobqueue_t* q = sem_ijq_new(new_init_proc());
    
    test_jq->q = q;
    jobqueue_t* jq = (jobqueue_t*) q->ijq->addr;
    
    test_jq->head = &jq->head;
    test_jq->tail = &jq->tail;
    test_jq->buf_size = &jq->buf_size;
    test_jq->jobs = jq->jobs;
    test_jq->capacity = (size_t (*)(void*)) sem_ijq_capacity;
    test_jq->is_full = (bool (*)(void*)) sem_ijq_is_full;
    test_jq->is_empty = (bool (*)(void*)) sem_ijq_is_empty;
    test_jq->enqueue = (void (*)(void*, job_t))  sem_ijq_enqueue;
    test_jq->dequeue = (job_t (*)(void*)) sem_ijq_dequeue;
    test_jq->peekhead = (job_t (*)(void*)) sem_ijq_peekhead;
    test_jq->peektail = (job_t (*)(void*)) sem_ijq_peektail;
        
    return test_jq;
}

static void test_tear_down(void* fixture) {
    test_jqueue_t* test_jq = (test_jqueue_t*) fixture;
    sem_ipc_jobqueue_t* q = (sem_ipc_jobqueue_t*) test_jq->q;
   
    proc_t* p = q->ijq->proc;
    sem_ijq_delete(q);
    proc_delete(p);
    free(test_jq);
}

static sem_ipc_jobqueue_t* assert_sem_ijq_new(proc_t* p) {
    sem_ipc_jobqueue_t* sijq = sem_ijq_new(p);
    assert_not_null(sijq);
    assert_not_null(sijq->ijq);
    assert_not_null(sijq->mutex);
    assert_not_null(sijq->full);
    assert_not_null(sijq->empty);
    
    assert_false(ipc_jq_is_full(sijq->ijq));
    assert_true(ipc_jq_is_empty(sijq->ijq));
#ifndef __APPLE__
    int val;

    (void) sem_getvalue(sijq->mutex, &val);    
    assert_int(val, ==, 1);

    (void) sem_getvalue(sijq->full, &val);    
    assert_int(val, ==, 0);

    (void) sem_getvalue(sijq->empty, &val);    
    assert_int(val, ==, ipc_jq_capacity(sijq->ijq));
    assert_int(val, ==, JOBQ_BUF_SIZE - 1);
#endif
    
    assert_init_jobqueue_state((jobqueue_t*) sijq->ijq->addr);

    return sijq;
}

static MunitResult test_sem_ijq_new_delete(const MunitParameter params[], 
    void* fixture) {
    test_procs_t* tp = new_test_procs();
    
    sem_ipc_jobqueue_t* qin = assert_sem_ijq_new(tp->pin);
    sem_ipc_jobqueue_t* qni = assert_sem_ijq_new(tp->pni);
    
    sem_ijq_delete(qni);
    
    sem_ijq_delete(qin);
    
    delete_test_procs(tp);
         
    return MUNIT_OK;
}

static MunitResult test_no_semfailure(MunitResult result) {
    if (result == MUNIT_OK)
        assert_int(errno, ==, 0);
    
    return result;
}

static MunitResult test_sem_ijq_capacity(const MunitParameter params[], 
    void* fixture) {
    return test_jqueue_capacity((test_jqueue_t*) fixture);
}

static MunitResult test_sem_ijq_is_full(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    
    return test_no_semfailure(test_jqueue_is_full((test_jqueue_t*) fixture));
}

static MunitResult test_sem_ijq_is_empty(const MunitParameter params[],
    void* fixture) {
    errno = 0;
    
    return test_no_semfailure(test_jqueue_is_empty((test_jqueue_t*) fixture));
}

static MunitResult test_sem_ijq_peekhead(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    
    return test_no_semfailure(test_jqueue_peekhead((test_jqueue_t*) fixture));
}

static MunitResult test_sem_ijq_peektail(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    
    return test_no_semfailure(test_jqueue_peektail((test_jqueue_t*) fixture));
}

static MunitResult test_sem_ijq_2proc_enqueue_dequeue(
    const MunitParameter params[], void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(cp);

        assert_not_null(sijq);
        
        for (int i = 0; i < sem_ijq_capacity(sijq) * 2; i++) {
            job_t j = { i, i + 1 };
            errno = 0;
            assert_true(job_is_equal(sem_ijq_dequeue(sijq), j));
            assert_int(errno, ==, 0);
        }
        
        sem_ijq_delete(sijq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(pp);

        assert_not_null(sijq);

        for (int i = 0; i < sem_ijq_capacity(sijq) * 2; i++) {
            job_t j = { i, i+1 };
            errno = 0;
            sem_ijq_enqueue(sijq, j);
            assert_int(errno, ==, 0);
        } 
        
        waitpid(pid, &child_stat, 0);
        assert_false(sem_ijq_is_full(sijq));
        assert_true(sem_ijq_is_empty(sijq));

        
        sem_ijq_delete(sijq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}

static MunitResult test_sem_ijq_2proc_peekhead(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(cp);

        assert_not_null(sijq);

        for (int i = 0; i < sem_ijq_capacity(sijq); i++) {
            job_t j = { i, i + 1 };
            sem_ijq_enqueue(sijq, j);
            errno = 0;
            assert_true(job_is_equal(sem_ijq_peektail(sijq), j));
            assert_int(errno, ==, 0);

            printf(".");
            fflush(stdout);
            delay_ms(50);
        } 
        
        printf("\n");
        
        delay_ms(500);
        sem_ijq_delete(sijq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(pp);

        assert_not_null(sijq);

        int i = 0;
        int count = 0;
        
        while (i < sem_ijq_capacity(sijq)) {
            errno = 0;
            job_t h = sem_ijq_peekhead(sijq);
            assert_int(errno, ==, 0);
            if (job_is_equal(h, UNUSED_ENTRY))
                delay_ms(10);
            else {
                job_t expected_j = { i, i + 1 };
                assert_true(job_is_equal(h, expected_j));
                
                errno = 0;
                assert_true(job_is_equal(sem_ijq_dequeue(sijq), expected_j));
                assert_int(errno, ==, 0);
                
                i++;
                count++;
            }
        }
        
        assert_int(count, ==, sem_ijq_capacity(sijq));
        assert_false(sem_ijq_is_full(sijq));
        assert_true(sem_ijq_is_empty(sijq));

        jobqueue_t* jq = (jobqueue_t*) sijq->ijq->addr;
        for (int i = 0; i < jq->buf_size; i++)
            assert_true(job_is_equal(jq->jobs[i], UNUSED_ENTRY));
        
        waitpid(pid, &child_stat, 0);

        sem_ijq_delete(sijq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}

static MunitResult test_sem_ijq_2proc_peektail(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = fork();
    
    if (pid < -1)
        return MUNIT_FAIL;
    
    if (pid == 0) {
        // in child
        proc_t* cp = new_init_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(cp);

        assert_not_null(sijq);

        for (int i = 0; i < sem_ijq_capacity(sijq); i++) {
            job_t j = {i, i + 1};
            errno = 0;
            sem_ijq_enqueue(sijq, j);
            assert_int(errno, ==, 0);
            printf(".");
            fflush(stdout);
            delay_ms(20);
        } 
        
        printf("\n");
        
        sem_ijq_delete(sijq);
        proc_delete(cp);
        
        exit(EXIT_SUCCESS);
    } else {
        // in parent
        int child_stat;

        proc_t* pp = new_noninit_proc();
        sem_ipc_jobqueue_t* sijq = sem_ijq_new(pp);

        assert_not_null(sijq);

        waitpid(pid, &child_stat, 0);

        assert_true(sem_ijq_is_full(sijq));
        assert_false(sem_ijq_is_empty(sijq));

        int i = 0;
        int capacity = sem_ijq_capacity(sijq);
        job_t expected_j = { capacity - 1, capacity};
        
        while (i < sem_ijq_capacity(sijq)) {
            errno = 0;
            job_t jt = sem_ijq_peektail(sijq);
            assert_int(errno, ==, 0);            
            assert_true(job_is_equal(jt, expected_j));
            
            errno = 0;            
            job_t j = { i, i + 1 };
            assert_true(job_is_equal(sem_ijq_dequeue(sijq), j));
            assert_int(errno, ==, 0);

            i++;
        }
        
        assert_false(sem_ijq_is_full(sijq));
        assert_true(sem_ijq_is_empty(sijq));
        
        sem_ijq_delete(sijq);
        proc_delete(pp);
        assert_int(WEXITSTATUS(child_stat), ==, EXIT_SUCCESS);
    }

    return MUNIT_OK;
}
